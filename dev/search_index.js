var documenterSearchIndex = {"docs":
[{"location":"library/","page":"Library","title":"Library","text":"CurrentModule = ExprParsers","category":"page"},{"location":"library/#Public-API","page":"Library","title":"Public API","text":"","category":"section"},{"location":"library/#Interface","page":"Library","title":"Interface","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"EP\nparse_expr\nto_expr\n@passert\nParseError","category":"page"},{"location":"library/","page":"Library","title":"Library","text":"EP\nparse_expr\nto_expr\n@passert\nParseError","category":"page"},{"location":"library/#ExprParsers.EP","page":"Library","title":"ExprParsers.EP","text":"EP = ExprParsers\n\nShort alias for the ExprParsers package.\n\n\n\n\n\n","category":"module"},{"location":"library/#ExprParsers.parse_expr","page":"Library","title":"ExprParsers.parse_expr","text":"parse_expr(parser, value)\n\nMatch parser against a value, will throw ParseError if the parser does not match.\n\nDefaults to comparing with ==, if matches, will return the value. Parsers will be called instead and return their parsed value.\n\nExamples\n\njulia> using ExprParsers\n\njulia> parse_expr(:a, :a)\n:a\njulia> parse_expr([1,2,3], [1,2,3])\n3-element Array{Int64,1}:\n 1\n 2\n 3\njulia> parse_expr([1,2,3], [1,2,35])\nERROR: ParseError: Using default `==` comparison, but parser `3` ≠ value `35`.\njulia> parse_expr(:(a = 4), :(a = 5))\nERROR: ParseError: Using default `==` comparison, but parser `4` ≠ value `5`.\njulia> parse_expr([1,2,3,4], [1,2])\nERROR: ParseError: length(parser) == length(values) = false\n  length(parser) = 4\n  parser = [1, 2, 3, 4]\n  length(values) = 2\n  values = [1, 2]\n\n\n\n\n\nAll ExprParserWithParsed have a common parse_expr method, namely that all struct fields are given directly as keyword arguments.\n\n\n\n\n\n","category":"function"},{"location":"library/#ExprParsers.to_expr","page":"Library","title":"ExprParsers.to_expr","text":"to_expr(parsed)\n\nConverts parsed information back to Expr.\n\nDefaults to returning same value, however if something knows about how it can be translated back, just overload the function.\n\n\n\n\n\n","category":"function"},{"location":"library/#ExprParsers.@passert","page":"Library","title":"ExprParsers.@passert","text":"@passert cond [text]\n\nThrow an ParseError if cond is false. Preferred syntax for writing assertions. Message text is optionally displayed upon assertion failure.\n\nIf no text is given a default rich text description is constructed, evaluating all found subexpressions for easier debugging.\n\nExamples\n\njulia> using ExprParsers\n\njulia> @passert iseven(3) \"3 is an odd number!\"\nERROR: ParseError: 3 is an odd number!\njulia> @passert isodd(3) \"What even are numbers?\"\n\njulia> a = 3;\n\njulia> @passert a+2 == 4\nERROR: ParseError: a + 2 == 4 = false\n  a + 2 = 5\n  a = 3\n\nAdapted from Base.@assert\n\n\n\n\n\n","category":"macro"},{"location":"library/#ExprParsers.ParseError","page":"Library","title":"ExprParsers.ParseError","text":"EP.ParseError\n\nSpecial Exception Type to indicate that some parsing failed.\n\n\n\n\n\n","category":"type"},{"location":"library/#Types","page":"Library","title":"Types","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"ExprParser\nExprParserWithParsed\nExprParsed\n@exprparser","category":"page"},{"location":"library/","page":"Library","title":"Library","text":"ExprParser\nExprParserWithParsed\nExprParsed\n@exprparser","category":"page"},{"location":"library/#ExprParsers.ExprParser","page":"Library","title":"ExprParsers.ExprParser","text":"EP.ExprParser\n\nAll parsers in the ExprParsers package inherit from this type.\n\n\n\n\n\n","category":"type"},{"location":"library/#ExprParsers.ExprParserWithParsed","page":"Library","title":"ExprParsers.ExprParserWithParsed","text":"EP.ExprParserWithParsed\n\nThis Type is mainly for internal usage. Please use @exprparser instead for the public interface.\n\nIt is a subtype of ExprParser which indicates that this parser actually constructs a ExprParsed object when calling parse_expr(parser, expr).\n\nThe resulting ExprParsed object is a struct with identical fields like the parser, where then the parsed values will be stored.\n\nExprParsed(parser::ExprParserWithParsed) will return the corresponding ExprParsed type.\n\n\n\n\n\n","category":"type"},{"location":"library/#ExprParsers.ExprParsed","page":"Library","title":"ExprParsers.ExprParsed","text":"EP.ExprParsed(ParserType::Type{<:ExprParserWithParsed}) -> Type{<:ExprParsed}\n\nMaps Parser Type to respective Parsed Type, and is also abstract super type of all Parsed types.\n\nExample\n\nEP.ExprParsed(EP.Assignment) == EP.Assignment_Parsed\n\n\n\n\n\n","category":"type"},{"location":"library/#ExprParsers.@exprparser","page":"Library","title":"ExprParsers.@exprparser","text":"EP.@exprparser struct MySymbol\n  symbol = EP.anything = :default_parsed_value\nend\n\nis transformed to\n\nBase.@kwdef struct MySymbol <: EP.ExprParserWithParsed\n  symbol = anything\nend\nBase.@kwdef mutable struct MySymbol_Parsed{T} <: EP.ExprParsed\n  symbol = :default_parsed_value\nend\nEP.ExprParsed(::Base.Type{MySymbol}) = MySymbol_Parsed\n\nIt defines the basics for an usual ExprParser, namely\n\nthe Parser type itself like specified in the original struct. It is always immutable - if you feel the need of mutating a parser, try to construct a new parser instead.\na corresponding Parsed type which will be used to hold parsed values. This is intentionally mutable as a usual workflow consists of adapting the parsed values to the needs of your macro, and if everything is changed, transform it back to an Expr using to_expr(parsed).\na mapping from the ExprParser to the ExprParsed\n\nAdditionally, the created MySymbol Parser supports the following default parse_expr functionality\n\nparser = MySymbol()\nparse_expr(parser, symbol = :hi)\n\nwhich translates to\n\nparser = MySymbol()\nMySymbol_Parsed(symbol = parse_expr(parser.symbol, :hi))\n\nThis is generic, and works similar if you have multiple fields.\n\n\n\nFinally, in order to finish your custom ExprParser definition, you just need to specialize the two main functions\n\nparse_expr(mysymbolparser::MySymbol, expr)\nto_expr(mysymbolparsed::MySymbol_Parsed)\n\nfunction EP.parse_expr(mysymbolparser::MySymbol, expr)\n  # do your custom parsing\n  # use @passert for checking parse assertions (it will have a nice and detailed default error message)\n  # construct your parsed result\n  MySymbol_Parsed(symbol = ...)\nend\n\nfunction EP.to_expr(parsed::MySymbol_Parsed)\n  # create a proper `Base.Expr` from your parsed result\n  # in this case it is simple\n  parsed.symbol\nend\n\n\n\n\n\n","category":"macro"},{"location":"library/#Core-ExprParser","page":"Library","title":"Core ExprParser","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"ExprParsers.Utils.Iterator\nSatisfiesPredicate\nIsa\nanything\nanysymbol\nAnyOf\nAllOf","category":"page"},{"location":"library/","page":"Library","title":"Library","text":"ExprParsers.Utils.Iterator\nSatisfiesPredicate\nIsa\nanything\nanysymbol\nAnyOf\nAllOf","category":"page"},{"location":"library/#ExprParsers.Utils.Iterator","page":"Library","title":"ExprParsers.Utils.Iterator","text":"EP.Iterator(some_iterable)\n\nMark an iterable explicitly as an Iterator to add support for elementwise parse_expr.\n\nExamples\n\njulia> using ExprParsers; using Base.Iterators\n\njulia> parser = EP.Iterator(repeated(4));\n\njulia> parse_expr(parser, [4, 4])\n2-element Array{Int64,1}:\n 4\n 4\njulia> parse_expr(parser, [4, 4, 4, 4])\n4-element Array{Int64,1}:\n 4\n 4\n 4\n 4\njulia> parse_expr(parser, [3, 4])\nERROR: ParseError: Using default `==` comparison, but parser `4` ≠ value `3`.\n\n\n\n\n\n","category":"type"},{"location":"library/#ExprParsers.SatisfiesPredicate","page":"Library","title":"ExprParsers.SatisfiesPredicate","text":"EP.SatisfiesPredicate(predicate_func[, errormessage])\n\nConstruct an ExprParser which checks whether the given predicate_func returns true. If so, the to-be-parsed value is returned as such, otherwise an ParseError is thrown as usual. If errormessage is given, it will be appended to the default error message.\n\nExample\n\njulia> using ExprParsers;\n\njulia> parser = EP.SatisfiesPredicate(isodd);\n\njulia> parse_expr(parser, 3)\n3\njulia> parse_expr(parser, 4)\nERROR: ParseError: Predicate `isodd` returned false on expr `4`.\njulia> is44(x) = x==44;\n\njulia> parser2 = EP.SatisfiesPredicate(is44, \"It should be 44.\");\n\njulia> parse_expr(parser2, 44)\n44\njulia> parse_expr(parser2, 4)\nERROR: ParseError: Predicate `is44` returned false on expr `4`. It should be 44.\n\n\n\n\n\n","category":"type"},{"location":"library/#ExprParsers.Isa","page":"Library","title":"ExprParsers.Isa","text":"EP.Isa(T::Type)\n\nConstructs an ExprParser which checks whether a value is of the given type.\n\nExample\n\njulia> using ExprParsers\n\njulia> parser = EP.Isa(Symbol);\n\njulia> parse_expr(parser, :thisisasymbol)\n:thisisasymbol\njulia> parse_expr(parser, 42)\nERROR: ParseError: Expected type `Symbol`, got `42` of type `Int64`.\n\nEP.Isa(Symbol) is so common that there is a special constant for it anysymbol.\n\n\n\n\n\n","category":"type"},{"location":"library/#ExprParsers.anything","page":"Library","title":"ExprParsers.anything","text":"EP.anything = Isa(Any)\n\nSpecial constant ExprParser which matches literally anything.\n\nExamples\n\njulia> using ExprParsers\n\njulia> parse_expr(EP.anything, 42)\n42\njulia> parse_expr(EP.anything, :whatever)\n:whatever\n\n\n\n\n\n","category":"constant"},{"location":"library/#ExprParsers.anysymbol","page":"Library","title":"ExprParsers.anysymbol","text":"EP.anysymbol = Isa(Symbol)\n\nSpecial constant ExprParser which matches Symbols, and only Symbols.\n\nExamples\n\njulia> using ExprParsers\n\njulia> parse_expr(EP.anysymbol, :asymbol)\n:asymbol\njulia> parse_expr(EP.anysymbol, 42)\nERROR: ParseError: Expected type `Symbol`, got `42` of type `Int64`.\n\n\n\n\n\n","category":"constant"},{"location":"library/#ExprParsers.AnyOf","page":"Library","title":"ExprParsers.AnyOf","text":"EP.AnyOf(parser1, parser2, parser3, ...; errormessage = \"\")\n\nConstructs an ExprParser from multiple given parsers. When given a value it first tries to match parser1, and if that fails with a ParseError, then parser2, and so forth. The result from the first parser which matches will be returned. If no parser matches, a dedicated ParseError is raised.\n\nIf errormessage is given, it will be appended to the default error message in case of ParseError.\n\nExamples\n\njulia> using ExprParsers\n\njulia> parser = EP.AnyOf(EP.anysymbol, EP.Isa(String), EP.SatisfiesPredicate(isodd),\n                         errormessage=\"My error message.\");\n\njulia> parse_expr(parser, :hi)\n:hi\njulia> parse_expr(parser, 3)\n3\njulia> parse_expr(parser, \"something\")\n\"something\"\njulia> parse_expr(parser, 4)\nERROR: ParseError: AnyOf could not parse expr `4` with any of the parsers `(ExprParsers.Isa{Symbol}(), ExprParsers.Isa{String}(), ExprParsers.SatisfiesPredicate{typeof(isodd)}(isodd, \"\"))`. My error message.\n\n\n\n\n\n","category":"type"},{"location":"library/#ExprParsers.AllOf","page":"Library","title":"ExprParsers.AllOf","text":"EP.AllOf(parser1, parser2, parser3, ...)\n\nConstructs an ExprParser from multiple given parsers. When to match a value, all parsers actually need to parse correctly, otherwise the ParseError from the first non-matching parser is rethrown. If all parsers match, then the return value from the last parser is returned.\n\nExamples\n\njulia> using ExprParsers\n\njulia> parser = EP.AllOf(EP.Isa(Number), EP.SatisfiesPredicate(isodd), 3);\n\njulia> parse_expr(parser, 3)\n3\njulia> parse_expr(parser, \"something\")\nERROR: ParseError: Expected type `Number`, got `something` of type `String`.\njulia> parse_expr(parser, 4)\nERROR: ParseError: Predicate `isodd` returned false on expr `4`.\njulia> parse_expr(parser, 5)\nERROR: ParseError: Using default `==` comparison, but parser `3` ≠ value `5`.\n\n\n\n\n\n","category":"type"},{"location":"library/#Meta-ExprParser","page":"Library","title":"Meta ExprParser","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Named\nIndexed","category":"page"},{"location":"library/","page":"Library","title":"Library","text":"Named\nIndexed","category":"page"},{"location":"library/#ExprParsers.Named","page":"Library","title":"ExprParsers.Named","text":"EP.Named{:MyTag}(parser)\n\nConstruct an ExprParser with a type identified by MyTag. This is helpful if you have multiple versions of a similar parser and would like to easily distinguish them during dispatch.\n\nThe Named{:MyTag} wrapper is also passed on to the parsed value.\n\nWorks with any ExprParser, also custom defined ones.\n\nExamples\n\njulia> using ExprParsers\n\njulia> parser1 = EP.Named{:simple}(EP.Assignment(left = EP.anysymbol));\n\njulia> parser2 = EP.Named{:any}(EP.Assignment());\n\njulia> parse_expr(parser1, :(a = 4))\nExprParsers.Named{:simple,ExprParsers.Assignment_Parsed}(EP.Assignment_Parsed(left=:a, right=4))\njulia> parse_expr(parser1, :(a.b = 4))\nERROR: ParseError: Expected type `Symbol`, got `a.b` of type `Expr`.\njulia> parse_expr(parser2, :(a = 4))\nExprParsers.Named{:any,ExprParsers.Assignment_Parsed}(EP.Assignment_Parsed(left=:a, right=4))\njulia> parse_expr(parser2, :(a.b = 4))\nExprParsers.Named{:any,ExprParsers.Assignment_Parsed}(EP.Assignment_Parsed(left=:(a.b), right=4))\n\n\n\n\n\n","category":"type"},{"location":"library/#ExprParsers.Indexed","page":"Library","title":"ExprParsers.Indexed","text":"EP.Indexed(func_expecting_dict_as_only_argument)\n\nConstructs an ExprParser where you can access dedicated subexpressions/subparsers via Dictionary lookup. Most importantly, the shortcuts are preserved during parse_expr().\n\nWorks with any ExprParser, also custom defined ones.\n\nConcretely, here a toy example\n\nEP.Indexed() do dict\n  EP.Expr(quote\n    a = $(dict[:a] = EP.Isa(Int))\n    b = $(dict[:b] = EP.anysymbol)\n  end)\nend\n\nAs you can see, EP.Indexed is expecting a function which takes a dict as the only argument. It best used with do-notation. The function then needs to return an ExprParser, but can do whatever it wants in principle. Shortcuts are now assigned by just using interpolation syntax $(...) and storing references to subparser into the given dict. For example you see that EP.Isa(Int) is captured as dict[:a] before being used as a subparser.\n\nExamples\n\njulia> using ExprParsers\n\njulia> parser = EP.Indexed() do dict\n         EP.Expr(quote\n           a = $(dict[:a] = EP.Isa(Int))\n           b = $(dict[:b] = EP.anysymbol)\n         end)\n       end;\n\njulia> parser[:a]\nExprParsers.Isa{Int64}()\njulia> parsed = parse_expr(parser, quote\n         a = 42\n         b = a\n       end);\n\njulia> parsed[:a], parsed[:b]\n(42, :a)\n\njulia> parse_expr(parser, quote\n         a = 42\n         b = :notasymbol\n       end);\nERROR: ParseError: Expected type `Symbol`, got `:notasymbol` of type `QuoteNode`.\n\n\n\n\n\n","category":"type"},{"location":"library/#ExprParserWithParsed","page":"Library","title":"ExprParserWithParsed","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"All these ExprParsers have a corresponding ..._Parsed object which captures the parsed information. I.e. there is EP.Function and when it is parsed with parse_expr it will return an EP.Function_Parsed.","category":"page"},{"location":"library/","page":"Library","title":"Library","text":"Expr\nBlock\nMacro\nAssignment\nNestedDot\nReference\nCall\nSignature\nFunction\nType\nTypeRange\nTypeAnnotation\nArg","category":"page"},{"location":"library/","page":"Library","title":"Library","text":"Expr\nBlock\nMacro\nAssignment\nNestedDot\nReference\nCall\nSignature\nFunction\nType\nTypeRange\nTypeAnnotation\nArg","category":"page"},{"location":"library/#ExprParsers.Expr","page":"Library","title":"ExprParsers.Expr","text":"EP.Expr(head = EP.anything, args = EP.anything)\nEP.Expr(expr; [ignore_linenumbernodes=true])\n\nIt is the most flexible parser, but hence also the least plug-and-play.\n\nParses the following\n\nBase.Expr(head, args...)\n\nExamples\n\njulia> using ExprParsers\n\njulia> parser = EP.Expr(head = :vect);\n\njulia> parse_expr(parser, :([1,2,3]))\nEP.Expr_Parsed(\n  head = :vect\n  args = Any[1, 2, 3]\n)\njulia> parse_expr(parser, :(f(a) = a))\nERROR: ParseError: Using default `==` comparison, but parser `:vect` ≠ value `:(=)`.\n\nAlso see Indexed for an example to combine EP.Indexed with EP.Expr.\n\n\n\n\n\n","category":"type"},{"location":"library/#ExprParsers.Block","page":"Library","title":"ExprParsers.Block","text":"EP.Block(block_expr; [ignore_linenumbernodes = true])\nEP.Block(expr1, expr2, ...; [ignore_linenumbernodes = true])\nEP.Block()\n\nHelper to parse blocks of code (i.e. expr.head == :block) or a given list of expr respectively.\n\nThe main purpose is to handle linenumbernodes, otherwise it behaves similar to plain Vector of Expr.\n\nParses the following\n\nquote\n  any\n  4\nend\n[:(a = 4), 42, :anyvector]\n(:(a = 4), 42, :or_tuple_of_expr)\nend\n\nExamples\n\njulia> using ExprParsers\n\njulia> parser = EP.Block(quote\n         $(EP.anything)\n         $(EP.anysymbol)\n         13\n       end);\n\njulia> parse_expr(parser, [:(a = 4), :hi, 13])\nEP.Block_Parsed(\n  exprs = Any[:(a = 4), :hi, 13]\n)\njulia> parse_expr(parser, quote\n         whatever(a) = a\n         asymbol\n         14\n       end)\nERROR: ParseError: Using default `==` comparison, but parser `13` ≠ value `14`.\n\nUsed within EP.Expr.\n\n\n\n\n\n","category":"type"},{"location":"library/#ExprParsers.Macro","page":"Library","title":"ExprParsers.Macro","text":"EP.Macro(name = EP.anything, args = EP.anything, linenumber = EP.Isa(LineNumberNode))\n\nParses the following\n\n@macroname arg1 arg2 ...\n\nExamples\n\njulia> using ExprParsers\n\njulia> parser = EP.Macro(name = :mymacro);\n\njulia> parse_expr(parser, :(@mymacro 1 two))\nEP.Macro_Parsed(\n  name       = :mymacro\n  args       = Any[1, :two]\n  linenumber = :(#= none:1 =#)\n)\njulia> parse_expr(parser, :(@anothermacro))\nERROR: ParseError: Using default `==` comparison, but parser `:mymacro` ≠ value `:anothermacro`.\n\n\n\n\n\n","category":"type"},{"location":"library/#ExprParsers.Assignment","page":"Library","title":"ExprParsers.Assignment","text":"EP.Assignment(left = EP.anything, right = EP.anything)\n\nParses the following\n\nleft = right\n\nExamples\n\njulia> using ExprParsers\n\njulia> parser = EP.Assignment(left = EP.anysymbol)\nEP.Assignment(\n  left  = ExprParsers.Isa{Symbol}()\n  right = ExprParsers.Isa{Any}()\n)\njulia> parse_expr(parser, :(a = [1,2,3,4]))\nEP.Assignment_Parsed(\n  left  = :a\n  right = :([1, 2, 3, 4])\n)\njulia> parse_expr(parser, :(f(a) = a))\nERROR: ParseError: Expected type `Symbol`, got `f(a)` of type `Expr`.\n\n\n\n\n\n","category":"type"},{"location":"library/#ExprParsers.NestedDot","page":"Library","title":"ExprParsers.NestedDot","text":"EP.NestedDot(base = EP.anything, properties = EP.anything)\n\nParses the following\n\na.b\nfun(T{:hi}).b.c.d.e.f\n\nExamples\n\njulia> using ExprParsers; using Base.Iterators\n\njulia> parser = EP.NestedDot(\n         properties = EP.Iterator(repeated(\n           EP.SatisfiesPredicate(\"It should start with 'a'.\") do x\n             startswith(string(x), \"a\")\n           end\n         ))\n       );\n\njulia> parse_expr(parser, :(fun(T{:hi}).aone.atwo.athree))\nEP.NestedDot_Parsed(\n  base       = :(fun(T{:hi}))\n  properties = [:aone, :atwo, :athree]\n)\njulia> parse_expr(parser, :(fun(T{:hi}).aone.btwo.athree))\nERROR: ParseError: Predicate `#1` returned false on expr `btwo`. It should start with 'a'.\n\n\n\n\n\n","category":"type"},{"location":"library/#ExprParsers.Reference","page":"Library","title":"ExprParsers.Reference","text":"EP.Reference(name = EP.anything, curlies = EP.anything)\n\nParses the following\n\na\na{b, c}\n\nExamples\n\njulia> using ExprParsers\n\njulia> parser = EP.Reference(curlies = [:A, EP.anysymbol])\nEP.Reference(\n  name    = ExprParsers.Isa{Any}()\n  curlies = Any[:A, ExprParsers.Isa{Symbol}()]\n)\njulia> parse_expr(parser, :(SomeType{A, B}))\nEP.Reference_Parsed(\n  name    = :SomeType\n  curlies = [:A, :B]\n)\njulia> parse_expr(parser, :(SomeType{A}))\nERROR: ParseError: length(parser) == length(values) = false\n  length(parser) = 2\n  parser = Any[:A, ExprParsers.Isa{Symbol}()]\n  length(values) = 1\n  values = Any[:A]\njulia> parse_expr(parser, :(SomeType{B, C}))\nERROR: ParseError: Using default `==` comparison, but parser `:A` ≠ value `:B`.\njulia> parse_expr(parser, :(SomeType{A, 1}))\nERROR: ParseError: Expected type `Symbol`, got `1` of type `Int64`.\n\n\n\n\n\n","category":"type"},{"location":"library/#ExprParsers.Call","page":"Library","title":"ExprParsers.Call","text":"EP.Call(\n  name = EP.anything,\n  curlies = EP.anything,\n  args = EP.anything,\n  kwargs = EP.anything)\n\nParses the following\n\na()\na(b, c)\na{b, c}(d, e)\na{b, c}(d, e, f = 1; g = :two)\n\nNote that all keyword arguments are collected into the kwargs field, also those before ;, corresponding to standard julia call semantics.\n\nNote that keyword arguments are represented using the default Expr representation Expr(:kw, :key, \"value\").\n\nExamples\n\njulia> using ExprParsers\n\njulia> parser = EP.Call(name = :myfunc)\nEP.Call(\n  name    = :myfunc\n  curlies = ExprParsers.Isa{Any}()\n  args    = ExprParsers.Isa{Any}()\n  kwargs  = ExprParsers.Isa{Any}()\n)\njulia> parse_expr(parser, :(myfunc(a, b, c = 1; d = :hi)))\nEP.Call_Parsed(\n  name    = :myfunc\n  curlies = Any[]\n  args    = Any[:a, :b]\n  kwargs  = Any[:($(Expr(:kw, :c, 1))), :($(Expr(:kw, :d, :(:hi))))]\n)\njulia> parse_expr(parser, :(anotherfunc(a, b, c = 1; d = :hi)))\nERROR: ParseError: Using default `==` comparison, but parser `:myfunc` ≠ value `:anotherfunc`.\n\n\n\n\n\n","category":"type"},{"location":"library/#ExprParsers.Signature","page":"Library","title":"ExprParsers.Signature","text":"EP.Signature(\n  name = EP.anything,\n  curlies = EP.anything,\n  args = EP.anything,\n  kwargs = EP.anything,\n  wheres = EP.anything)\n\nSimilar to EP.Call but with a couple of differences\n\nextra wheres\nthe name field might stay empty\nargs can also contain Expr(:kw, key, value) values (corresponds to default value syntax, which is only available in signatures)\n\nParses the following:\n\na(b, c::Any)\na(b::B, c) where B\n(::Any, c::C) where {C <: Number}\nf(::Any, c::C, d::Int=1; e=true) where {C <: Number}\n\nExamples\n\njulia> using ExprParsers\n\njulia> parser = EP.Signature()\nEP.Signature(\n  name    = ExprParsers.Isa{Any}()\n  curlies = ExprParsers.Isa{Any}()\n  args    = ExprParsers.Isa{Any}()\n  kwargs  = ExprParsers.Isa{Any}()\n  wheres  = ExprParsers.Isa{Any}()\n)\njulia> parse_expr(parser, :(f{T}(a::T) where T))\nEP.Signature_Parsed(\n  name    = :f\n  curlies = Any[:T]\n  args    = Any[:(a::T)]\n  kwargs  = Any[]\n  wheres  = Any[:T]\n)\njulia> parse_expr(parser, :((a, b::T) where T))\nEP.Signature_Parsed(\n  name    = nothing\n  curlies = Any[]\n  args    = Any[:a, :(b::T)]\n  kwargs  = Any[]\n  wheres  = Any[:T]\n)\njulia> parse_expr(parser, :(f(a, b::T, c::Any=3; d=true) where T))\nEP.Signature_Parsed(\n  name    = :f\n  curlies = Any[]\n  args    = Any[:a, :(b::T), :($(Expr(:kw, :(c::Any), 3)))]\n  kwargs  = Any[:($(Expr(:kw, :d, true)))]\n  wheres  = Any[:T]\n)\njulia> parse_expr(parser, :(f(a) = a))\nERROR: ParseError: expr.head in (:where, :call, :tuple) = false\n  expr.head = :(=)\n  expr = :(f(a) = begin\n          #= none:1 =#\n          a\n      end)\n  (:where, :call, :tuple) = (:where, :call, :tuple)\n\n\n\n\n\n","category":"type"},{"location":"library/#ExprParsers.Function","page":"Library","title":"ExprParsers.Function","text":"EP.Function(\n  name = EP.anything,\n  curlies = EP.anything,\n  args = EP.anything,\n  kwargs = EP.anything,\n  wheres = EP.anything,\n  body = EP.anything)\n\nParses full functions. For instance\n\nfunction a(b, c) where B\n  d\nend\na(b, c) = d\n\nExamples\n\njulia> using ExprParsers\n\njulia> parser = EP.Function(\n         args = [EP.anything for i in 1:3],\n       )\nEP.Function(\n  name    = ExprParsers.Isa{Any}()\n  curlies = ExprParsers.Isa{Any}()\n  args    = [ExprParsers.Isa{Any}(), ExprParsers.Isa{Any}(), ExprParsers.Isa{Any}()]\n  kwargs  = ExprParsers.Isa{Any}()\n  wheres  = ExprParsers.Isa{Any}()\n  body    = ExprParsers.Isa{Any}()\n)\njulia> parse_expr(parser, :(f(a, b, c) = a + b + c))\nEP.Function_Parsed(\n  name    = :f\n  curlies = Any[]\n  args    = [:a, :b, :c]\n  kwargs  = Any[]\n  wheres  = Any[]\n  body    = quote\n    #= none:1 =#\n    a + b + c\nend\n)\njulia> parse_expr(parser, :(\n         function g(a)\n           a\n         end\n       ))\nERROR: ParseError: length(parser) == length(values) = false\n  length(parser) = 3\n  parser = [ExprParsers.Isa{Any}(), ExprParsers.Isa{Any}(), ExprParsers.Isa{Any}()]\n  length(values) = 1\n  values = Any[:a]\njulia> parse_expr(parser, :a)\nERROR: ParseError: ExprParsers.Function has no `parse_expr` method defined to capture Type `Symbol`. Got: `a`.\n\n\n\n\n\n","category":"type"},{"location":"library/#ExprParsers.Type","page":"Library","title":"ExprParsers.Type","text":"EP.Type(name = EP.anything, curlies = EP.anything, wheres = EP.anything)\n\nParses the following:\n\na\na{b, c}\na{d} where d\n\nExamples\n\njulia> using ExprParsers\n\njulia> parser = EP.Type()\nEP.Type(\n  name    = ExprParsers.Isa{Any}()\n  curlies = ExprParsers.Isa{Any}()\n  wheres  = ExprParsers.Isa{Any}()\n)\njulia> parse_expr(parser, :(Array{T, 2} where T))\nEP.Type_Parsed(\n  name    = :Array\n  curlies = Any[:T, 2]\n  wheres  = Any[:T]\n)\njulia> parse_expr(parser, :(f(1,2)))\nERROR: ParseError: Cannot parse expr `f(1, 2)` as reference: expr.head `call` not in `[:curly, :.]`.\n\n\n\n\n\n","category":"type"},{"location":"library/#ExprParsers.TypeRange","page":"Library","title":"ExprParsers.TypeRange","text":"EP.TypeRange(lb = EP.anything, name = EP.anything, ub = EP.anything)\n\nNote: Construct with typevar = EP.anysymbol to guarantee that only plain symbols can be used as type variable.\n\nParses the following.\n\nTypeVar >: LowerBound\nTypeVar <: UpperBound\nLowerBound <: TypeVar <: UpperBound\n\nExamples\n\njulia> using ExprParsers\n\njulia> parser = EP.TypeRange(name = EP.anysymbol)\nEP.TypeRange(\n  lb   = ExprParsers.Isa{Any}()\n  name = ExprParsers.Isa{Symbol}()\n  ub   = ExprParsers.Isa{Any}()\n)\njulia> parse_expr(parser, :(Int <: T <: Number))\nEP.TypeRange_Parsed(\n  lb   = :Int\n  name = :T\n  ub   = :Number\n)\njulia> parse_expr(parser, :(T <: Number))\nEP.TypeRange_Parsed(\n  lb   = Union{}\n  name = :T\n  ub   = :Number\n)\njulia> parse_expr(parser, :(Int <: 4)) # CAUTION: when using single `<:`, the order is decisive!\nEP.TypeRange_Parsed(\n  lb   = Union{}\n  name = :Int\n  ub   = 4\n)\njulia> parse_expr(parser, :(4 >: Int))\nERROR: ParseError: Expected type `Symbol`, got `4` of type `Int64`.\njulia> parse_expr(parser, :(4 <: Int))\nERROR: ParseError: Expected type `Symbol`, got `4` of type `Int64`.\n\n\n\n\n\n","category":"type"},{"location":"library/#ExprParsers.TypeAnnotation","page":"Library","title":"ExprParsers.TypeAnnotation","text":"EP.TypeAnnotation(name = EP.anything, type = EP.anything)\n\nParses the following\n\na\na::B\n::B\n\nExamples\n\njulia> using ExprParsers\n\njulia> parser = EP.TypeAnnotation(type = :Int)\nEP.TypeAnnotation(\n  name = ExprParsers.Isa{Any}()\n  type = :Int\n)\njulia> parse_expr(parser, :(::Int))\nEP.TypeAnnotation_Parsed(\n  name = nothing\n  type = :Int\n)\njulia> parse_expr(parser, :(a::Int))\nEP.TypeAnnotation_Parsed(\n  name = :a\n  type = :Int\n)\njulia> parse_expr(parser, :(a::String))\nERROR: ParseError: Using default `==` comparison, but parser `:Int` ≠ value `:String`.\n\n\n\n\n\n","category":"type"},{"location":"library/#ExprParsers.Arg","page":"Library","title":"ExprParsers.Arg","text":"EP.Arg(name = EP.anything, type = EP.anything, default = EP.anything)\n\nA missing default value is indicated by the special variable EP.nodefault which is the unique instance of the singleton type EP.NoDefault.\n\nParses the following\n\na\na::B\n::B\na = c  # only :($(Expr(:kw, :a, :c))), not plain :(a = c)\na::B = c  # only :($(Expr(:kw, :(a::B), :c))), not plain :(a::B = c)\n\nExamples\n\njulia> using ExprParsers\n\njulia> parser = EP.Arg()\nEP.Arg(\n  name    = ExprParsers.Isa{Any}()\n  type    = ExprParsers.Isa{Any}()\n  default = ExprParsers.Isa{Any}()\n)\njulia> parse_expr(parser, :(a::B))\nEP.Arg_Parsed(\n  name    = :a\n  type    = :B\n  default = ExprParsers.NoDefault()\n)\njulia> parse_expr(parser, Expr(:kw, :a, 3))\nEP.Arg_Parsed(\n  name    = :a\n  type    = Any\n  default = 3\n)\njulia> parse_expr(parser, :(a = 3))\nERROR: ParseError: AnyOf could not parse expr `a = 3` with any of the parsers `(ExprParsers.Isa{Symbol}(), EP.TypeAnnotation(name=ExprParsers.Isa{Any}(), type=ExprParsers.Isa{Any}()))`. Arg should either be a Symbol or a TypeAnnotation.\njulia> parse_expr(parser, :(f(a)))\nERROR: ParseError: AnyOf could not parse expr `f(a)` with any of the parsers `(ExprParsers.Isa{Symbol}(), EP.TypeAnnotation(name=ExprParsers.Isa{Any}(), type=ExprParsers.Isa{Any}()))`. Arg should either be a Symbol or a TypeAnnotation.\n\n\n\n\n\n","category":"type"},{"location":"manual/#Manual","page":"Manual","title":"Manual","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"ExprParsers exports a constant EP which is an alias for the package ExprParsers itself. This comes in very handy when you use the custom parsers a lot.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"The main interface encompass just three concepts, which seamlessly interact with oneanother","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"macro EP.@exprparser: easily create definitions for highly flexible and nestable parsers\nfunction parse_expr: compares a parser with a value, and returns a parsed result\nfunction to_expr: transforms parsed values back to Base.Expr","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Many parsers have already been defined, ready for use, and well documented. Take a look at Public API.","category":"page"},{"location":"manual/#Extended-Example:-Part-I-Combining-Parsers","page":"Manual","title":"Extended Example: Part I Combining Parsers","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"To understand how to work with ExprParsers in practice, it is best to see a full-fledged example.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"One nice and complex task would be to implement support for the traitor-like-syntax introduced by the package Traitor.jl. The syntax may no longer be the nicest, but still it is quite powerful and serves as a good example (I myself build another Traits package which extends where syntax instead, which many people may find more intuitive these days WhereTraits.jl).","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"In Traitor syntax, you have a double type annotation argument::StandardType::TraitsType. The StandardType is a plain julia type like Int or AbstractArray. The TraitsType is something similar to Base.HasEltype or Base.HasLength. For our goal it doesn't matter so much, we just want to parse the syntax.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Let's start with loading the package and creating a default parser for functions.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"julia> using ExprParsers\n\njulia> parser_function = EP.Function(name = EP.anysymbol)\nEP.Function(\n  name    = ExprParsers.Isa{Symbol}()\n  curlies = ExprParsers.Isa{Any}()\n  args    = ExprParsers.Isa{Any}()\n  kwargs  = ExprParsers.Isa{Any}()\n  wheres  = ExprParsers.Isa{Any}()\n  body    = ExprParsers.Isa{Any}()\n)","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"As you can see, we only gave a subparser for the field name which captures the function name. All other substructures default to be able to parse anything.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Now we parse our first function. Mind that we need to use :(...) for constructing Expr, as quote...end would introduce an additional Expr(:block, ...) layer.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"julia> parsed_function = parse_expr(parser_function, :(\n         function f(a, b::Int::HasSomeTrait)\n            \"a = $a, b = $b, sometrait(b) = $(sometrait(b))\"\n         end\n       ))\nEP.Function_Parsed(\n  name    = :f\n  curlies = Any[]\n  args    = Any[:a, :((b::Int)::HasSomeTrait)]\n  kwargs  = Any[]\n  wheres  = Any[]\n  body    = quote\n    #= none:3 =#\n    \"a = $(a), b = $(b), sometrait(b) = $(sometrait(b))\"\nend\n)","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"We have our parsed function, but the arguments are still quite rough. Lets parse them further by using EP.Arg. Conveniently, all ExprParsers support broadcasting syntax.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"julia> parsed_args = parse_expr.(EP.Arg(), parsed_function.args)\n2-element Array{ExprParsers.Arg_Parsed,1}:\n EP.Arg_Parsed(name=:a, type=Any, default=ExprParsers.NoDefault())\n EP.Arg_Parsed(name=:(b::Int), type=:HasSomeTrait, default=ExprParsers.NoDefault())","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"That is nice, we captured HasSomeTrait in the type field. This is because argument::StandardType::TraitsType is evaluated as (argument::StandardType)::TraitsType. So we would like to get access to the b::Int as well.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"But now things start to get difficult, because there is also :a with type=Any, and somehow we need to separate both cases.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"We can easily do this by defining more specific parsers. Lets start with the \"standard\" Parser.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"julia> parser_standard_arg = EP.Arg(name=EP.anysymbol)\nEP.Arg(\n  name    = ExprParsers.Isa{Symbol}()\n  type    = ExprParsers.Isa{Any}()\n  default = ExprParsers.Isa{Any}()\n)\njulia> parse_expr(parser_standard_arg, parsed_function.args[1])\nEP.Arg_Parsed(\n  name    = :a\n  type    = Any\n  default = ExprParsers.NoDefault()\n)\njulia> parse_expr(parser_standard_arg, parsed_function.args[2])\nERROR: ParseError: Expected type `Symbol`, got `b::Int` of type `Expr`.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"That looks very good: Our new parser only parsers standard arguments and fails on traitor-like syntax. In addition it super simple - we just required the name to be a Base.Symbol.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Now let's define the traitor-argument. We know that the \"name\" field will be just another type-annotation. Let's use that knowledge straight away.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"julia> parser_traitor_arg = EP.Arg(name=EP.TypeAnnotation())\nEP.Arg(\n  name    = EP.TypeAnnotation(name=ExprParsers.Isa{Any}(), type=ExprParsers.Isa{Any}())\n  type    = ExprParsers.Isa{Any}()\n  default = ExprParsers.Isa{Any}()\n)\njulia> parse_expr(parser_traitor_arg, parsed_function.args[1])\nERROR: ParseError: ExprParsers.TypeAnnotation has no `parse_expr` method defined to capture Type `Symbol`. Got: `a`.\njulia> parse_expr(parser_traitor_arg, parsed_function.args[2])\nEP.Arg_Parsed(\n  name    = EP.TypeAnnotation_Parsed(name=:b, type=:Int)\n  type    = :HasSomeTrait\n  default = ExprParsers.NoDefault()\n)","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"It worked. We only parsed traitor syntax, and now have all the components readily available.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"We have all the pieces together, now we just need to combine them. EP.AnyOf is the natural choice to combine multiple parsers by falling back to the next if the first fails.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"julia> parser_arg = EP.AnyOf(parser_standard_arg, parser_traitor_arg)\nExprParsers.AnyOf{Tuple{ExprParsers.Arg,ExprParsers.Arg}}((EP.Arg(name=ExprParsers.Isa{Symbol}(), type=ExprParsers.Isa{Any}(), default=ExprParsers.Isa{Any}()), EP.Arg(name=EP.TypeAnnotation(name=ExprParsers.Isa{Any}(), type=ExprParsers.Isa{Any}()), type=ExprParsers.Isa{Any}(), default=ExprParsers.Isa{Any}())), \"\")\njulia> parse_expr(parser_arg, parsed_function.args[1])\nEP.Arg_Parsed(\n  name    = :a\n  type    = Any\n  default = ExprParsers.NoDefault()\n)\njulia> parse_expr(parser_arg, parsed_function.args[2])\nEP.Arg_Parsed(\n  name    = EP.TypeAnnotation_Parsed(name=:b, type=:Int)\n  type    = :HasSomeTrait\n  default = ExprParsers.NoDefault()\n)\njulia> parse_expr.(parser_arg, parsed_function.args)\n2-element Array{ExprParsers.Arg_Parsed,1}:\n EP.Arg_Parsed(name=:a, type=Any, default=ExprParsers.NoDefault())\n EP.Arg_Parsed(name=EP.TypeAnnotation_Parsed(name=:b, type=:Int), type=:HasSomeTrait, default=ExprParsers.NoDefault())","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"There we are! We have build or parsing pipeline in a very straightforward and intuitive manner and ended up at having all the information parsed in a need way.","category":"page"},{"location":"manual/#Extended-Example:-Part-II-Working-with-parsed-results","page":"Manual","title":"Extended Example: Part II Working with parsed results","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"One thing which is missing though, is to extract the information in a convenient way. In julia the most convenient way is to use dispatch. But how to dispatch in the example above? Both versions are of type ExprParsers.Arg_Parsed.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"We could have made the types more complicated, e.g. by including the types of all subparsers as well, however we decided against it and in favour for a simple meta-type EP.Named{Tag}. Bringing this into a meta-expr-parser has the big advantage that you can easily create your own ExprParsers without bothering about the precise types you use.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"EP.Named{Tag}(some_parser) constructs a named version of your parser, which preserves the name when put through parse_expr. That is it's key purpose. Let's see it it in action.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"julia> parser_arg_named = EP.AnyOf(\n         EP.Named{:standard}(parser_standard_arg),\n         EP.Named{:traitor}(parser_traitor_arg)\n       )\nExprParsers.AnyOf{Tuple{ExprParsers.Named{:standard,ExprParsers.Arg},ExprParsers.Named{:traitor,ExprParsers.Arg}}}((ExprParsers.Named{:standard,ExprParsers.Arg}(EP.Arg(name=ExprParsers.Isa{Symbol}(), type=ExprParsers.Isa{Any}(), default=ExprParsers.Isa{Any}())), ExprParsers.Named{:traitor,ExprParsers.Arg}(EP.Arg(name=EP.TypeAnnotation(name=ExprParsers.Isa{Any}(), type=ExprParsers.Isa{Any}()), type=ExprParsers.Isa{Any}(), default=ExprParsers.Isa{Any}()))), \"\")\njulia> parsed_args = parse_expr.(parser_arg_named, parsed_function.args)\n2-element Array{ExprParsers.Named{Name,ExprParsers.Arg_Parsed} where Name,1}:\n ExprParsers.Named{:standard,ExprParsers.Arg_Parsed}(EP.Arg_Parsed(name=:a, type=Any, default=ExprParsers.NoDefault()))\n ExprParsers.Named{:traitor,ExprParsers.Arg_Parsed}(EP.Arg_Parsed(name=EP.TypeAnnotation_Parsed(name=:b, type=:Int), type=:HasSomeTrait, default=ExprParsers.NoDefault()))","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"We did the same as before, but added some type-tags to the results. You see that wrapping a parser into EP.Named{Tag}(...) will seamlessly and intuitively pass on the Tag to the parsed result. That is exactly what we need to simplify our dispatch.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Finally, let's write some utility which extracts all the Traitor information in a custom type.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"julia> Base.@kwdef struct TraitorArg\n         name\n         type\n         traitstype\n         default\n       end\nTraitorArg\njulia> extract_traitsarg(parsed::EP.Named{:standard}) = TraitorArg(\n         name = parsed[].name,\n         type = parsed[].type,\n         traitstype = Any,\n         default = parsed[].default,\n       )\nextract_traitsarg (generic function with 1 method)\njulia> extract_traitsarg(parsed::EP.Named{:traitor}) = TraitorArg(\n         name = parsed[].name.name,\n         type = parsed[].name.type,\n         traitstype = parsed[].type,\n         default = parsed[].default,\n       )\nextract_traitsarg (generic function with 2 methods)\njulia> traitor_args = extract_traitsarg.(parse_expr.(parser_arg_named, parsed_function.args))\n2-element Array{TraitorArg,1}:\n TraitorArg(:a, Any, Any, ExprParsers.NoDefault())\n TraitorArg(:b, :Int, :HasSomeTrait, ExprParsers.NoDefault())","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Super clean result and intuitive Julian style of programming. You can see that the use of EP.Named actually simplified the dispatch a lot and made it extremely readable.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"From here on you can start to fill the traitor syntax with life. It turns out that we missed on one special Traitor-syntax case. Concretely, the argument style a::::TraitsType is officially supported, but not captured by either of the above. If I got you motivated, try to implement this case yourself!","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"I hope you enjoyed this extended example and got a good feeling of how to work with ExprParsers.","category":"page"},{"location":"manual/#Extended-Example:-Part-III-creating-Expr-again","page":"Manual","title":"Extended Example: Part III creating Expr again","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"Almost forgot: When defining your own macro there will come the time when you want to construct Expr objects again in order to return them to the user.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"ExprParsers are also made for this task. One way to do this is to manipulate the parsed results directly. Let's see what this means.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"julia> using ExprParsers\n\njulia> parsed = parse_expr(EP.Function(), :(f(x) = x))\nEP.Function_Parsed(\n  name    = :f\n  curlies = Any[]\n  args    = Any[:x]\n  kwargs  = Any[]\n  wheres  = Any[]\n  body    = quote\n    #= none:1 =#\n    x\nend\n)\njulia> parsed.name = :anothername;\n\njulia> parsed\nEP.Function_Parsed(\n  name    = :anothername\n  curlies = Any[]\n  args    = Any[:x]\n  kwargs  = Any[]\n  wheres  = Any[]\n  body    = quote\n    #= none:1 =#\n    x\nend\n)\njulia> to_expr(parsed)\n:(function anothername(x)\n      #= none:1 =#\n      x\n  end)","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"The key is that every parsed result can be converted to an Expr by using to_expr.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"The second way to construct Expr is by constructing parsed objects directly. You just have to use the EP.Function_Parsed instead of EP.Function, i.e. appending _Parsed to your parser type and you get the constructor for the parsed object. It supports keyword assignment together with useful default values. In general it is very handy.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"julia> using ExprParsers\n\njulia> func = EP.Function_Parsed(\n         name = :myfunc,\n         args = [:(a::T), EP.Arg_Parsed(name = :b, default = 42)],\n         kwargs = [EP.Arg_Parsed(name = :c, default = :hi)],\n         wheres = [:T],\n         body = :(a + b)\n       )\nEP.Function_Parsed(\n  name    = :myfunc\n  curlies = Any[]\n  args    = Any[:(a::T), EP.Arg_Parsed(name=:b, type=Any, default=42)]\n  kwargs  = ExprParsers.Arg_Parsed[EP.Arg_Parsed(name=:c, type=Any, default=:hi)]\n  wheres  = [:T]\n  body    = :(a + b)\n)\njulia> to_expr(func)\n:(function myfunc(a::T, b = 42; c = hi) where T\n      a + b\n  end)","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"For instance, for the Traitor syntax such manual construction would be needed, as quite some transformations need to happen to arrive at the traits semantics. As you can see, it is very easy to do this using ExprParsers.","category":"page"},{"location":"manual/#Extended-Example:-Part-IV-Defining-your-own-ExprParser-with-EP.@exprparser","page":"Manual","title":"Extended Example: Part IV Defining your own ExprParser with EP.@exprparser","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"As a final little excurse about the Traitor syntax example, I would like to show you how you can easily build your own ExprParsers using the macro EP.@exprparsers. It is also used internally to most of the parsers available.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"For example, let us rewrite the previous code which we used to extract Traitor information. For easier reference, here a self-containing copy of what we did above:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"julia> using ExprParsers\n\njulia> parser_standard_arg = EP.Arg(name=EP.anysymbol);\n\njulia> parser_traitor_arg = EP.Arg(name=EP.TypeAnnotation());\n\njulia> parser_arg_named = EP.AnyOf(\n         EP.Named{:standard}(parser_standard_arg),\n         EP.Named{:traitor}(parser_traitor_arg),\n       );\n\njulia> Base.@kwdef struct TraitorArg\n         name\n         type\n         traitstype\n         default\n       end\nTraitorArg\njulia> extract_traitsarg(parsed::EP.Named{:standard}) = TraitorArg(\n         name = parsed[].name,\n         type = parsed[].type,\n         traitstype = Any,\n         default = parsed[].default,\n       )\nextract_traitsarg (generic function with 1 method)\njulia> extract_traitsarg(parsed::EP.Named{:traitor}) = TraitorArg(\n         name = parsed[].name.name,\n         type = parsed[].name.type,\n         traitstype = parsed[].type,\n         default = parsed[].default,\n       )\nextract_traitsarg (generic function with 2 methods)\njulia> # which we then used for extraction\n\njulia> parsed_function = parse_expr(EP.Function(), :(\n         function f(a, b::Int::HasSomeTrait)\n            \"a = $a, b = $b, sometrait(b) = $(sometrait(b))\"\n         end\n       ));\n\njulia> traitor_args = extract_traitsarg.(parse_expr.(parser_arg_named, parsed_function.args))\n2-element Array{TraitorArg,1}:\n TraitorArg(:a, Any, Any, ExprParsers.NoDefault())\n TraitorArg(:b, :Int, :HasSomeTrait, ExprParsers.NoDefault())","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"We can easily transform this into a full-fledged ExprParser by making using of the EP.@exprparser macro.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"julia> EP.@exprparser struct TraitorArgExprParser\n         name = EP.anything\n         type = EP.anything = Any\n         traitstype = EP.anything = Any\n         default = EP.anything = EP.nodefault\n       end;\n\njulia> function EP.parse_expr(parser::TraitorArgExprParser, expr)\n         _parse_expr_traitor(parser, parse_expr(parser_arg_named, expr))\n       end;\n\njulia> _parse_expr_traitor(parser, parsed::EP.Named{:standard}) = parse_expr(parser,\n         name = parsed[].name,\n         type = parsed[].type,\n         traitstype = Any,\n         default = parsed[].default,\n       )\n_parse_expr_traitor (generic function with 1 method)\njulia> _parse_expr_traitor(parser, parsed::EP.Named{:traitor}) = parse_expr(parser,\n         name = parsed[].name.name,\n         type = parsed[].name.type,\n         traitstype = parsed[].type,\n         default = parsed[].default,\n       )\n_parse_expr_traitor (generic function with 2 methods)\njulia> function EP.to_expr(parsed::TraitorArgExprParser_Parsed)\n         if parsed.default === EP.nodefault\n           if parsed.traitstype == Any\n             :($(parsed.name)::$(parsed.type))\n           else\n             :($(parsed.name)::$(parsed.type)::$(parsed.traitstype))\n           end\n         else\n           # Note that function keyword arguments are constructed using `Expr(:kw, ...)` and not plain `=`\n           if parsed.traitstype == Any   \n             Expr(:kw, :($(parsed.name)::$(parsed.type)), parsed.default)\n           else\n             Expr(:kw, :($(parsed.name)::$(parsed.type)::$(parsed.traitstype)), parsed.default)\n           end\n         end\n       end;\n","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"That defines the ExprParser as well as the key interface parse_expr and to_expr. Let's go through it one by one. First we defined the parser using EP.@exprparser. It is very much identical to defining a simple struct with Base.kwdef support, only that in addition you can make use of a neat double-default-syntax. default = EP.anything = EP.nodefault means that the \"first\" default value EP.anything is the default sub-parser which is used when constructing an TraitorArgExprParser, while the \"second\" default value EP.nodefault is the default value used when constructing the parsed result TraitorArgExprParser_Parsed.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Then we defined parse_expr(...) for our new type, which simply dispatches on the Named{Tag} parsers within the sub-function _parse_expr_traitor to actually construct the parsed results. One general feature we used here is that parse_expr(...) by default always supports a generic keyword syntax parse_expr(parser, field1 = :value_to_be_parsed, field2 = ...) which translates to constructing the parsed result, with all fields matched by the respective sub-parsers ..._Parsed(field1 = parse_expr(parser.field1, :value_to_be_parsed), field2 = ...). Using this syntax we make sure that always all sub-parsers are actually used and not overlooked accidentally.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Finally we also overloaded EP.to_expr on top of the ..._Parsed type so that we can easily convert traitor arguments back to proper Base.Expr objects.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"It is not much to define, and everything very straightforward. Now we have a fully flexible full-fledged TraitorArgument parser. Let's see it in action.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"julia> parser_traitor_arg = TraitorArgExprParser(default = EP.Isa(Union{EP.NoDefault, Int}))\nEP.TraitorArgExprParser(\n  name       = ExprParsers.Isa{Any}()\n  type       = ExprParsers.Isa{Any}()\n  traitstype = ExprParsers.Isa{Any}()\n  default    = ExprParsers.Isa{Union{ExprParsers.NoDefault, Int64}}()\n)\njulia> traitor_args = parse_expr.(parser_traitor_arg, parsed_function.args)\n2-element Array{TraitorArgExprParser_Parsed,1}:\n EP.TraitorArgExprParser_Parsed(name=:a, type=Any, traitstype=Any, default=ExprParsers.NoDefault())\n EP.TraitorArgExprParser_Parsed(name=:b, type=:Int, traitstype=:HasSomeTrait, default=ExprParsers.NoDefault())\njulia> traitor_arg = parse_expr(parser_traitor_arg, Expr(:kw, :(a::Int::TraitsType), 4))  # Note that we need to use `Expr(:kw, ...)` to construct function keyword arguments\nEP.TraitorArgExprParser_Parsed(\n  name       = :a\n  type       = :Int\n  traitstype = :TraitsType\n  default    = 4\n)\njulia> to_expr(traitor_arg)\n:($(Expr(:kw, :((a::Int)::TraitsType), 4)))\njulia> parse_expr(parser_traitor_arg, Expr(:kw, :(a::String::TraitsType), \"hi\"))\nERROR: ParseError: Expected type `Union{ExprParsers.NoDefault, Int64}`, got `hi` of type `String`.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"All works well, and also our example restriction to only accept Int default values, or no default at all, works as intended. As you see, the ExprParsers package even comes with pretty printing of your custom @exprparser type.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"The ExprParsers package, with parse_expr, to_expr and @exprparser at its core, provides an interface which is easy to understand, easy to work with and easy to extend. Having defined the interface, many tedious and repetitive Expr-parsing tasks are well encapsulated and it becomes much easier to construct further macro-semantics on top of it.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"I hope you enjoy the package.","category":"page"},{"location":"#ExprParsers.jl","page":"Home","title":"ExprParsers.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"ExprParsers is a library made to simplify development of elaborate macros.","category":"page"},{"location":"","page":"Home","title":"Home","text":"What ExprParsers offers is a set of curated parsers for common Expr patterns. For example","category":"page"},{"location":"","page":"Home","title":"Home","text":"parse_expr(ExprParsers.Function(), :(f(a) = 2a))","category":"page"},{"location":"","page":"Home","title":"Home","text":"will give you an ExprParsers.Function_Parsed object where you can inspect and change name, args, kwargs, curlies, wheres, and the function body. It just works and you don't have to bother any longer that you can also write the same function as function f(a); 2a; end - the parser handles this for you.","category":"page"},{"location":"","page":"Home","title":"Home","text":"In macros you often not only want to inspect the given Expr in efficient and stable manners, but also may want to change parts and return a respectively adapted Expr. For this purpose, all Parsed objects can be converted back to Expr by using the to_expr() method.","category":"page"},{"location":"","page":"Home","title":"Home","text":"We guarantee that parse_expr and to_expr are working nicely together, i.e. the following always holds for arbitrary expressions and parsers","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using ExprParsers\n\njulia> # comes with a shorthand EP for ExprParsers\n\njulia> parser = EP.Function()\nEP.Function(\n  name    = ExprParsers.Isa{Any}()\n  curlies = ExprParsers.Isa{Any}()\n  args    = ExprParsers.Isa{Any}()\n  kwargs  = ExprParsers.Isa{Any}()\n  wheres  = ExprParsers.Isa{Any}()\n  body    = ExprParsers.Isa{Any}()\n)\n\njulia> expr = :(f(a) = 2a)\n:(f(a) = begin\n          #= REPL[8]:1 =#\n          2a\n      end)\n\njulia> parsed = parse_expr(parser, expr)\nEP.Function_Parsed(\n  name    = :f\n  curlies = Any[]\n  args    = Any[:a]\n  kwargs  = Any[]\n  wheres  = Any[]\n  body    = quote\n    #= REPL[8]:1 =#\n    2a\nend\n)\n\njulia> # applying the parser \"twice\" returns always the same parsed result\n\njulia> parse_expr(parser, to_expr(parsed)) == parsed\ntrue","category":"page"},{"location":"","page":"Home","title":"Home","text":"Note that ExprParsers exports a constant EP which is an alias for the package ExprParsers itself. This comes in very handy when you use the custom parsers a lot.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Checkout the test/ directory for seeing more examples, especially test/expr_parsers_with_parsed.jl where for each common Expr pattern a parser is put into action.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using Pkg\npkg\"add ExprParsers\"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Use it like","category":"page"},{"location":"","page":"Home","title":"Home","text":"using ExprParsers","category":"page"},{"location":"#Manual-Outline","page":"Home","title":"Manual Outline","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"manual.md\"]","category":"page"},{"location":"#main-index","page":"Home","title":"Library Outline","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"library.md\"]","category":"page"},{"location":"#Library-Index","page":"Home","title":"Library Index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"library.md\"]","category":"page"}]
}
